//부산모각코 

const [users, setUsers] = useState([]); 중 각 부분에 대한 설명
users;(상태변수): 상태라고 부르는 react내부 저장공간.
setUsers;(상태 업데이트 함수): 상태를 바꿀 떄 사용하는 함수
useState([]);(초기값 설정 + hook): 상태를 생성하고 initial state(초기 상태값)을 []로 설정 

//왜 react는 이런 형태를 쓰냐
React는 “함수형 UI”를 지향하기 때문에
상태(state) 라는 개념이 특별히 필요함.

왜냐면 화면을 다시 그릴 때마다 함수가 다시 실행되는데
그 사이에도 값이 계속 유지되어야 하기 때문.

axios = fetch를 편하게 쓰는 도구.
데이터는 axios에 저장되지 않고 React state에 저장됨.

useEffect는 화면상에서 상태변환이 일어나면 활성화되는 함수다 ;리렌더링된 후 실행되는 “사이드 이펙트 함수”.


익명함수: () => {}; (): 매개변수 {...}: 함수본문(실행 코드 블록)
useEffect(콜백함수, 의존성배열);

useEffect는 **“React가 호출하는 함수”**라 우리가 이름 붙여서 변수에 넣지 않음.
// 리엑트가 호출한다는게 화면변환에 의해 지가 알아서 호출해서 변수에 굳이 대입을 안한다는말이네

useEffect(콜백함수, 의존성배열)"callback: 함수를 받는 함수": 콜백 함수는 "useEffect가 나중에 실행할 함수"이기 때문에
함수명을 붙이지 않고 익명 함수로 넣는 게 일반적임. 그리고 콜백 함수는 매개변수를 사용하지 않음.
// 그니까 함수안에 함수가있어서 안의함수의 값이 돌아온다고해서 콜백함수인거네 뒤에 의존성배열은 뭐임?

React는 콜백 함수를 많이 쓰기 때문에
굳이 이름이 필요 없는 경우 → 익명 함수(() => {})로 바로 전달하는 것. 원하면 함수명을 붙여서 변수로 저장해 써도 됨.
방식 1) 익명 함수 바로 전달
useEffect(() => { ... }, []);

방식 2) 미리 함수를 변수로 만들고 전달
const load = () => { ... };
useEffect(load, []);

방식 3) 함수 선언문 사용도 가능
function load() { ... }
useEffect(load, []);

✔ useEffect(() => {}, [])
useEffect: 함수명(React Hook)
() => {}: 콜백 함수 / 익명 함수
[]: 의존성 배열

✔ const load = () => {}
load: 함수명(변수명)
() => {}: 함수
useEffect(load, []): 함수 전달 + 의존성 배열