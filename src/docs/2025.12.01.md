📘 react-today.md (오늘 학습 정리)
# 📘 React Today Summary (2025-12-01)

# 1. 함수 선언 vs 함수 표현식
### ✔ 함수 선언(Function Declaration)
```jsx
function add() {}


“add라는 이름의 함수를 만들겠다”

호이스팅 됨

컴포넌트 만들 때 자주 사용

✔ 함수 표현식(Function Expression)
const add = () => {};


변수에 함수를 저장

이벤트 핸들러로 자주 사용(onClick 등)

2. 조건문에서 return 사용
if (num1 === 0) return;


조건이 참이면 현재 함수 실행을 즉시 종료

예: -1 되지 않도록 막는 코드에 많이 사용

3. useEffect와 감시배열
useEffect(() => {
    if (num1 === 0) {
        alert("현재 값은 0입니다.");
    }
}, [num1]);

✔ 감시 배열(deps)

[num1] → num1이 변경될 때만 실행

[] → 마운트 시 1번 실행

배열 비우면 마운트 시점에만 동작

✔ 마운트 / 언마운트

마운트: 컴포넌트가 화면에 등장하는 순간

언마운트: 컴포넌트가 사라지는 순간

✔ useEffect 실행 순서

컴포넌트 실행

JSX return

화면 렌더링

useEffect 실행

즉시 실행처럼 보이지만 실제로는 렌더링 이후 실행하는 훅.

4. axios / Promise / async-await
✔ axios 설치
npm install axios

✔ sweetalert2 설치
npm install sweetalert2

✔ axios 기본 패턴
axios.get("/api/users").then(res => {
    console.log(res.data);
});

✔ 비동기(await) 패턴
const response = await axios.get("/api/users");
console.log(response.data);

✔ Promise 기본 구조
return new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve({
            status: 200,
            data: [10,20,30]
        });
    }, 2000);
});

✔ 공통 API 요청 함수 패턴
const getRequest = async (url) => {
    const r = await axios.get(url);
    return r;
};

5. React 기본 개념 정리
✔ 컴포넌트

JSX를 return하는 함수

대문자로 시작해야 함

재사용 가능한 UI 조각

✔ 상태(state)

화면에 영향을 주는 값

값이 바뀌면 자동으로 리렌더링

✔ 렌더링(Rendering)

JSX → JS 객체 → HTML → 화면 출력

React는 “상태가 바뀌면 그 부분만 효율적으로 다시 그림”

✔ 마운트

컴포넌트가 화면에 등장하는 순간

이때 useEffect([])가 실행됨

✔ 언마운트

컴포넌트가 사라질 때

useEffect의 return(cleanup)이 실행됨

✔ DOM

HTML 요소들

React는 Virtual DOM을 이용한 비교(diffing)로 빠르게 업데이트함

6. JSX vs HTML
HTML	JSX
<div class="box">	<div className="box">
<input>	<input />
onclick	onClick
class	className

JSX는 babel/swc가 HTML로 변환해줌

JSX는 JS문법이므로 { } 안에 값, 변수, 함수 등 넣을 수 있음

예:

let a = 5;
<div>{a}</div>  // {} 안에는 값만 들어갈 수 있음

7. Props 개념

Props = 부모가 자식에게 전달하는 "객체 형태의 데이터"

변수/함수 모두 전달 가능

예:

<InputBox name={username} onChange={handleInput} />


자식:

function InputBox({ name, onChange }) {
    return <input value={name} onChange={onChange} />;
}

8. 스프레드 / 레스트 / 구조분해
✔ 스프레드
const a = { x: 1, y: 2 };
const b = { ...a }; // a 복사

✔ 배열 구조분해 + 레스트
const arr = [1, 2, 3, 4];
const [a1, a2, ...arr2] = arr;

// arr2 = [3, 4];

9. 렌더링 및 함수 호출 구조
✔ 부모-자식 함수 호출 구조
fx() 호출 → fx1, fx2, fx3 전부 실행됨
fx3 단독 호출 → fx만 호출되는 건 아님

✔ 상태 위치의 중요성
<div>
  상태 a
  <B />
  <C />
  <D />
</div>


상태 A가 바뀌면
→ 그 상태를 포함한 상위 컴포넌트 전체가 리렌더링
→ 그 아래 자식들도 리렌더링 영향 받음

10. 기타 요약

JSX 함수가 너무 복잡하면 컴포넌트로 분리(모듈화)

input[e.target.name] 에서 []는 “해당 값으로 key를 사용하라”는 의미

모든 자료형 기억할 필요 없음 → console.log() 먼저 찍고 판단